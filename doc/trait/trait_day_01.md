# Scala Trait Day 01

## Today
- traitの話（座学）

## trait
- 特徴・性質・特質などを意味する言葉
- Scalaでは実装を持つJavaのinterfaceに近い
- classは1つのsuper classしか持てないが、traitは複数個をミックスインすることができる
- よくあるサンプル
  - シンインタフェースをリッチインタフェースにする
  - 積み重ね可能な変更（Stackable Trait）
  - Cake Pattern による DI
    - Component Abstractions

## Scala trait の話の前に
- ミックイン(mix-in)的な考え方を知るための基本のふりかえりをしましょう
  - traitを使った設計の役にも立つはずです

## classの役割
* まとまったものを作る生成器
  * クラスはたい焼きを作るための「たい焼きの型」
  * 分類（まさにclasses)
  * ユーザが定義できるtype（型）
* どういう操作が可能かという仕様
  * C++/Java/Scala 存在しないメソッドの呼び出しはコンパイルエラー
* コードを再利用するための単位
  * 継承による再利用<br>
注意
  * 言語によって違うのであまり面倒な話はしませんよ
  * ALGOL/Simula/Smalltalk/C++をどうぞ

## 継承
* 一般化・特殊化
  * 親クラスで一般的な機能を実装し、子クラスで目的に特化した機能を実装する
  * 子クラスは親クラスの一種であると言える
    * よくきく is-a関係が成り立つ
    * リスコフの置換原則 
* 共通部分の抽出
  * 複数のクラスの共通部分をその親クラスにする
  * is-a がいいえになることが多い
* 差分実装
  * 継承して変更点だけ実装すると効率が良い
  * 実装の再利用がメイン
  * is-a は成り立たないことが多い

## リスコフの置換原則
- 図がない！
  - 簡単な例は Map、HashMap、TreeMap

## 継承の問題
- 深い継承ツリーは人間には認知できない
  - 変数だらけのスコープの実装は追えないと同じ
  - 脳がStack Over Flow
  - 修正による影響範囲怖い
- 現実のもの（オブジェクト）はどこに分類したらいいかわからないことも多い
  - ファイル・ディレクトリのツリー構造でファイルをどこにおくか悩むのと一緒
    - ファイルサーバとかどこにファイル置くべきか？
  - よろしいならば多重継承だ！
    - 実装の再利用としては非常に便利！！！
    - BUT 菱形継承問題
    - https://ja.wikipedia.org/wiki/%E8%8F%B1%E5%BD%A2%E7%B6%99%E6%89%BF%E5%95%8F%E9%A1%8C

## 多重継承
- 実装の再利用として非常に便利
- Pythonの例
  - ForkingMixin, ThreadingMixin
  - UDPServer, TCPServer
  - の４つのclassを多重継承で組み合わせるだけで
  - 4種類のclassが作れる的な実装
  - ForkingUDPServer, ThreadingUDPServer
  - ForkingTCPServer, ThreadingTCPServer
  - 上記のクラスには実装はなくクラス宣言のみ
- 問題点
  - 菱形継承問題
  - どっちの親のメソッドが呼ばれるんですか？問題

## 多重継承に対する対応
- 解決順序の工夫する
  - 線形化(linearization)
  - C3線形化
    - 親クラスは子クラスより先に探索されない
    - 先に書いてる方優先
- 多重継承を禁止する(Java)
  - 実装の再利用を目的とした継承を避ける
  - 委譲(delegate)使う
    - has-a
    - ここでDI登場
  - interfaceを多重継承可能にする
    - 仕様の表明の役割だけ切り離す
- Mix-in

## Mix-in
- 祖先を辿る方法が複数あるので問題
- 再利用したい機能だけを持った小さなクラスを作って、その機能を追加したい大きなクラスに混ぜこんで使おう
- 設計方針や混ぜ込むクラスのことはMix-inと呼ぶ

## RubyとPythonのMix-in
- Ruby
  - module が再利用のための機能
  - includeして使う
  - 名前が衝突すると乙！
- Python
  - 多重継承がOKなので、クラス名にMixinてつけようねという雰囲気でGO
  - いつインスタンスとして使える状態になるか？の表明ができない
    - 何と何を混ぜないといけませんよ！やどの抽象メソッドを具体にしないといけませんよの宣言ができない

## Trait
- そもそも「クラスには2つの相反する役割がある」これが悪い
- 1つは「インスタンスを作るためのもの」
  - 完結した必要なものをすべて持つ大きなクラス
- ２つは「再利用の単位」
  - 機能毎の余計なものをもたない小さなクラス
- クラスは再利用の単位として大きすぎる
- 再利用の役割に特化した小さな構造が必要
- そこで trait ですよ！

## Scalaのtrait
- コードの再利用のための仕組み
- abstractとimplの混在による仕様の表明ができる
  - mix-inして使うにはこのメソッドは実装してねが言える
- 再利用できる
  - mix-inは何個でもOK(super classは1つまで)
  - クラスをリッチにできる
  - 名前の衝突も検出できるので安全

## Scalaのtrait サンプル
- シンインタフェース vs リッチインタフェース
- インタフェースにメソッドいっぱいあると再利用しづらい（リッチすぎる問題）
- シンインタフェースをリッチにする方法
- インタフェースが実装を持てる
  - Java8のデフォルト実装と同じ感じ
- シンを実装するだけでリッチになるインタフェースが作れる件

## シンインタフェース？リッチインタフェース？
- シンインタフェースをリッチインタフェースにする
- インタフェースは実装持ていないのでメソッドが多いと実装者の負担が大きい
- もしインタフェースが実装も持つことができれば実装者の負担が低い but リッチなインタフェースにできるという話

## Stackable な Trait
- 変更の積み重ねというおそろしい技
- traitの線形化ルールにより積み重ね可能な変更ができる
- new IntQueue extends Doubling with Incrementing
- new IntQueue extends Incrementing with Doubling

## 自分型アノテーションによるDI
- 基本はテスト可能にするため
- 数パターン実装する

## trait の概要
- 基本コンストラクタは引数なし
- 補助コンストラクタは禁止
- 抽象メンバー・具象メンバーともにOK

## trait か classか迷ったら
- ふるまいが再利用されない場合は class
- 複数の無関係なクラスで再利用される可能性がある場合は trait
- Javaコードを継承できるようにしたい場合 class
- ライブラリをコンパイル後の形態で配布したい場合（外部の開発者が継承してクラスを書くことを想定する場合） class
- 処理効率が非常に重視される場合 class
- 以上を検討してもはっきりしない場合はとりあえずtraitにしておけば？

## Next
- 次のネタ
  - traitの続き
  - traitのシンタックス的な概要
  - リッチインタフェース写経
  - Stackable Traitの写経

----
[Scala Trait Day 02へ](trait_day_02.md)
